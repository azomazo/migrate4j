<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>migrate4j</title>

<style type="text/css" >
	div {text-align: left;} 
</style>
</head>
<body>

<div style="text-align: center;"><h2>Welcome to</h2>
<h1><big>migrate4j</big></h1>

<br>
<br />
<div><b>migrate4j</b> makes it possible to keep database schemas in sync across
multiple machines.  It strives to be Java's answer to the db:migrate rake task in
Rails. While it isn't a replacement or clone, it does provide simple
configuration, flexibility and ease of use in a database migration tool.<br />
<br />
Status of migrate4j is available on our <a href="status.html">Status Page</a>.
</div>
<br />
<h3>A Sample Migration</h3>
<div>Normally, adding a table to a database involves logging into your database and
issuing a DDL (Data Definition Language) command.  Repeat this for every developer, 
test and production machine.  Every time your schema changes, you repeat the above steps.
While it's uncommon to use databases from more than one vendor, or to switch from one
database product to another, this obviously complicates this process. 
</div>
<br/>
<div>
With <b>migrate4j</b>, schema changes are applied through "Migrations".  For example, 
to add a simple table, write a Java class such as:
<pre>
package db.migrations;

import static com.eroi.migrate.Define.*;
import static com.eroi.migrate.Execute.*;

import com.eroi.migrate.Migration;

public class Migration_0 implements Migration {

	public void up() {
		createTable(
			table("simple_table", 
				column("id", DataTypes.INTEGER, primarykey(), notnull()),
				column("desc", DataTypes.VARCHAR, length(50), defaultValue("NA"))));
	}

	public void down() {
		dropTable("simple_table");
	}
}
</pre>
</div>
<br />
<div>
The above class can be applied on the command line, within code (like an initialization method)
or an Ant task.  This allows automating schema changes so that when one developer makes a 
change, all other developers have the changes applied to their systems on their next checkout.
And if a change needs to get rolled back, <b>migrate4j</b> makes going back to a previous version
trivial.
</div>

<h3>Why <b>migrate4j</b>?</h3>
<div>
<b>migrate4j</b> allows you to define Migrations, or database schema changes, in Java.  
This provides some nice benefits:
<ul>
<li>Each schema change is database independent - no need to write an SQL script for each
target database</li>
<li>Schema changes can be automated - no more emailing the development team to tell them
to upgrade their schemas</li>
<li>Changes can be partially applied - if multiple changes are needed, apply as many, or
as few, as you'd like</li>
<li>Rollback changes with ease - reverting your source code back to a previous version and need the 
database schema to match?  No problem!</li>
<li>Changes can be applied through code, on the command line, or from an Ant script to
automate schema synchronization.
<ul>
</div>
<div>
Schema changes in <b>migrate4j</b> are defined in "Migration" classes.  These are
easy to read and write, and remove the need to research vendor specific DDL syntax.
A sample migration, that adds a simple table, looks like:
 <pre>
package db.migrations;

import static com.eroi.migrate.Define.*;
import static com.eroi.migrate.Execute.*;

import com.eroi.migrate.Migration;

public class Migration_0 implements Migration {

	public void up() {
		createTable(
			table("simple_table", 
				column("id", DataTypes.INTEGER, primarykey(), notnull()),
				column("desc", DataTypes.VARCHAR, length(50), defaultValue("NA"))));
	}

	public void down() {
		dropTable("simple_table");
	}
}
</pre>
</div>
<div>
Migrations such as the above can be applied, or rolled back, from code, the command line
or in Ant scripts. This allows you to push Migrations out with each upgrade and
have them applied when the application starts up.  During development, while the
schema is highly subject to change, your team can easily modify their schemas,
including rolling back to a previous state if needed.  And you'll have a convenient 
history of all your schema changes, right there in your source code!
</div>

<h3>Using <b>migrate4j</b></h3>
<div>
Using <b>migrate4j</b> is as easy as setting up a package and adding classes that
implement the <b><a href="#migrations">Migration</a></b> interface.  By
convention, each class is named "Migration_X", with X representing a numerical order for the file to 
be applied in.  For example, you might create the following classes:
<ul>
	<li>Migration_1</li>
	<li>Migration_2</li>
	<li>Migration_3</li>
</ul>
These will be applied, as you might imagine, in the order listed above.  You can apply all of them by
simply calling:
<pre>Engine.migrate()</pre>
Or, apply just Migration_1 with:
<pre>Engine.migrate(1)</pre>
Or, roll all of them back (assuming they've been applied) by simply running:
<pre>Engine.migrate(0)</pre>
<br>
</div>
<a name="migrations" id="migrations"></a><h3>Writing a Migration</h3>
<div>
Writing a Migration class is easy.  There are only 2 methods that you need to worry about - "up" and "down".
The "up" method is called when Migrations are applied and "down" is called when they're being rolled back.
To make things even easier, most migrations can be created by using just a couple of classes: Define and Execute.</div>
<br />
<div>
Define provides methods that help you easily define schema elements (tables, columns, indexes, etc) in a vendor
independent fashion.  Execute applies schema changes (add, change, rename, etc) to a database without having to
worry about the syntax requirements of the target database.
</div>
<br />
<div>
A typical Migration that simply adds a table might look like:
<pre>
package db.migrations;

import static com.eroi.migrate.Define.*;
import static com.eroi.migrate.Execute.*;

import com.eroi.migrate.Migration;

public class Migration_0 implements Migration {

	public void up() {
		createTable(
			table("simple_table", 
				column("id", DataTypes.INTEGER, primarykey(), notnull()),
				column("desc", DataTypes.VARCHAR, length(50), defaultValue("NA"))));
	}

	public void down() {
		dropTable("simple_table");
	}
}
</pre>
</div>
<br />
<div>
If you've used DDL (Data Definition Language) to "CREATE TABLE" in SQL, this probably makes sense.  
Take a look at the API for more information on how to build and modify schemas to meet your needs.
</div>
<br />
<a name="applymigrations" id="applymigrations"></a><h3>Configuring the database</h3>
<div>
Before <b>migrate4j</b> can modify your database's schema, it must know how to connect to it.
It also needs a way to keep track of the state of your schema (and what better place to do that
than in a database?). This means, you'll need to provide <b>migrate4j</b> some configuration
information, as well as a table in your database to use for keeping track of it's work.
</div>
<div>
While it's possible to configure <b>migrate4j</b> in code, the most flexible method is to 
provide a configuration file in your classpath.  By default, <b>migrate4j</b> looks for a 
file named "migrate4j.properties" 
</div>
<br />
<div>
Configuring <b>migrate4j</b> can be done programmatically, or with a configuration file.
  
</div>
<h3>Current status</h3>
<div>
Having read all that, hopefully you're eager to get started using <b>migrate4j</b> in your project.  But before you
do that, there are some things you should know.  First, <b>migrate4j</b> is a very new project.  Many of the things that
were mentioned above may still be "theoretical" in nature.  For example, while you can certainly run the code samples we've 
shown on multiple databases, we may not have support for your particular product yet.  And while adding and dropping tables
can be done now, indexes, foreign keys and other elements may not have made it into the build yet.   In fact, when we 
said "you can look at the API for more information" . . . we're getting to it!
</div>
<br />
<div>
You may get a better idea by checking our <a href="status.html">Status Page</a>.  While there's no guarantee this page will
always reflect new code submissions, it's a pretty safe bet that what's listed on that page is going to work.  Of course, if
you find something listed that you can't get working, be sure to let us know!
</div>
<br />
<div>
You can help fix and improve <b>migrate4j</b>!  If you'd like to volunteer to help make <b>migrate4j</b> better, we'll welcome you with 
open arms.  But you don't need to make that big of a commitment.  The biggest help we can get right now is 
feedback.  Tell us what features we need to add to make <b>migrate4j</b> the database migration project that
you'll start using on your own projects.  Visit <a href="http://sourceforge.net/projects/migrate4j">our sourceforge page</a> and
send us a message at <b>toddrun at users.sourceforge.net</b> (replacing the "at" with the at symbol) with your thoughts, ideas, suggestions, criticisms and concerns.  We want to make migrate4j
the defacto Java migration project - your input can help make that happen.
</div>
<br />
<div style="text-align: center;"><a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=207661&amp;type=4" alt="SourceForge.net Logo" border="0" height="37" width="125">

</a></div>
</body>
</html>
