<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Welcome to Migrate4j</title>

  <style type="text/css">
	<!--
	@page { size: 8.5in 11in; margin: 0.79in }
	P { margin-bottom: 0.08in }
	H3 { margin-bottom: 0.08in }
	H3.western { font-family: "Helvetica" }
	H3.cjk { font-family: "AR PL ShanHeiSun Uni" }
	H3.ctl { font-family: "Lucidasans" }
	H1 { margin-bottom: 0.08in }
	H1.western { font-family: "Helvetica"; font-size: 16pt }
	H1.cjk { font-family: "AR PL ShanHeiSun Uni"; font-size: 16pt }
	H1.ctl { font-family: "Lucidasans"; font-size: 16pt }
	-->
  </style>
</head>
<body>


<h1>Welcome to migrate4j</h1>

<ul>
<li><a href="#whatis">What is migrate4j?</a></li>
<li><a href="#quickstart">Quick Start</a></li>
<li><a href="#configuring">Configuring migrate4j</a></li>
<li><a href="#writing">Writing Migrations</a></li>
<li><a href="#applying">Applying Migrations</a></li>
<li><a href="#ant">The Ant Task and command line Engine</a></li>
<li><a href="#help">Getting Help</a></li>
</ul>

<h3 class="western"><a name="whatis" />What is migrate4j?</h3>

<p style="margin-bottom: 0in;">migrate4j is a database
migration tool.
Suppose you determine that you need a new database table for your
project. If you develop alone, you could write an SQL script that
adds the table and manually apply this to your development system.
But if you work with other developers, or need to keep a test system
in synch with your development system, this become tedious and error
prone.</p>

<p style="margin-bottom: 0in;">Migration tools make it
possible to add
your new table (or make any other schema changes) in an automated
fashion, ensuring all your systems are always in synch. Migration
tools also make it possible to quickly and easily roll back previous
changes. Unlike typing commands into an interactive SQL window or
storing SQL scripts, migration tools keep a detailed history of how
your database schema evolved (just in case you need to go back to a
previous version). Finally, migration tools minimize or eliminate the
problem of having to use vendor specific syntax &ndash; you may
never
switch database products, but if you do, using a migration tool will
make your life much easier.</p>

<p style="margin-bottom: 0in;">The initial intent of
migrate4j was to
make a Java version of Ruby's db:migrate. If you've used db:migrate,
you probably fell in love with it's simple syntax, easy configuration
and ability to roll changes up and back effortlessly. The intent (and
the challenge) of migrate4j is to bring the power and simplicity of
db:migrate to Java programmers, using familiar type safety and
syntax. Along the way, we're adding additional functionality that
make migrate4j more than just another Ruby tool rewritten for Java
&ndash;
it is a Java project intended to make other Java projects even
better.</p>

<p style="margin-bottom: 0in;"><br>

</p>

<h1 class="western"><a name="quickstart" />Quick Start</h1>

<h3 class="western">Configure migrate4j</h3>

<p style="margin-bottom: 0in;">Manually apply the
following SQL to
your database:</p>

<pre>create table version (version int primary key);<br>insert into version values (0);</pre>

<p style="margin-bottom: 0in;">Create a file named
&ldquo;migrate4j.properties&rdquo; and add the following text
(replacing the
values in &lt;tags&gt; with actual values for your database.</p>

<pre>connection.url=&lt;jdbc connection url such as &ldquo;jdbc:mysql://localhost:3306/mydb &rdquo;&gt;<br>connection.driver=&lt;jdbc driver class name such as &ldquo;com.mysql.jdbc.Driver&rdquo;&gt;<br>connection.username=&lt;username&gt;<br>connection.password=&lt;password&gt;<br>migration.package.name=db.migrations</pre>

<p style="margin-bottom: 0in;">Save this file to the
source directory
of your project.</p>

<h3 class="western">Write a migration</h3>

<p style="margin-bottom: 0in;">Create a new package named
&ldquo;db.migrations&rdquo; in the source directory of your
project. Create a
new Java file in the &ldquo;db.migrations&rdquo; package named
&ldquo;Migration_1&rdquo;.
Add the following code:</p>

<pre>package db.migrations; </pre>

<pre>import static com.eroi.migrate.Define.*;<br>import static com.eroi.migrate.Define.DataTypes.*;<br>import static com.eroi.migrate.Execute.*; </pre>

<pre>import com.eroi.migrate.Migration; </pre>

<pre>public class Migration_1 implements Migration { </pre>

<pre>&nbsp; public void up() {<br>&nbsp; &nbsp; createTable(<br>&nbsp; &nbsp; &nbsp; &nbsp; table("simple_table",<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column("id", INTEGER, primarykey(), notnull()),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column("desc", VARCHAR, length(50), defaultValue("NA"))));<br>&nbsp; } </pre>

<pre>&nbsp; public void down() {<br>&nbsp; &nbsp; dropTable("simple_table");<br>&nbsp; }<br>} </pre>

<p style="margin-bottom: 0in;">Copy the migrate4j.jar file
and
commons-logging.jar file into the source directory of your project.
Compile Migration_1 - the following command should accomplish this:</p>

<pre>javac -classpath migrate4j.jar db/migrations/Migration_1.java </pre>

<h3 class="western">Apply the migration</h3>

<p style="margin-bottom: 0in;">Locate migrate4j.jar,
commons-logging.jar and the jar for your JDBC database driver jar
(the following assumes these are in your projects source directory).
To apply Migration_1, run the following command from the command
line:</p>

<pre>java -cp .:mysql.jar:migrate4j.jar:lib/commons-logging.jar com.eroi.migrate.Engine</pre>

<p style="margin-bottom: 0in;">Your database should now
include
&ldquo;simple_table&rdquo;. To remove the table, rerun the
Engine with a
target version of &ldquo;0&rdquo;:</p>

<pre>java -cp .:mysql.jar:migrate4j.jar:lib/commons-logging.jar com.eroi.migrate.Engine 0</pre>

<h1 class="western"><a name="configuring" />Configuring migrate4j</h1>

<h3 class="western">Connection and package
configuration</h3>

<p style="margin-bottom: 0in;">Configuring migrate4j is
achieved
through the Configure class. In some cases, by simply providing a
migrate4j.properties file is all you need to do. For example, the
Ant task that comes with migrate4j, and calling the Engine class from
the command line (as shown in the Quick Start section of this
manual), handle the call to Configure automatically. However, the
Configure class offers a lot of flexibility.</p>

<p style="margin-bottom: 0in;">Before any migrations are
applied (or
rolled back), one of the &ldquo;configure&rdquo; methods must
be called on
the Configure class. These methods include (among others):</p>

<pre>configure()<br>configure(Connection, String)<br>configure(String, String, String, String, String, String, String, String, Integer, String)</pre>

<p style="margin-bottom: 0in;">The no argument option
loads properties
from a file named &ldquo;migrate4j.properties&rdquo; that is
found on the
classpath (a sample of this file comes with the migrate4j
distribution file). Obviously, being able to call
Configure.configure() within your code, and modify a single file
should your connection details change, is extremely convenient. The
Ant task that comes with migrate4j, and the command line usage shown
in the Quick Start section of the manual, both use this form of the
configure method. This form of &ldquo;configure&rdquo; is
generally good for
automating migrations within a development environment (if you choose
not to use the Ant task).</p>

<p style="margin-bottom: 0in;">The method that accepts a
Connection
and String accepts an active javax.sql.Connection object and the
fully qualified package name where you Migration classes reside. This
option works well for situations where a Connection is already
available. For example, if you're using a connection pool or can
obtain a connection from a JNDI repository, using this form of the
configure method allows passing in a existing connection. One thing
to remember is that migrate4j will not close the connection &ndash;
you
need to do this after running the Engine. This form of
&ldquo;configure&rdquo;
is a good choice for ensuring your database schema is at the lastest
version during application startup (perhaps in an initialization
servlet or in a main JFrame).</p>

<p style="margin-bottom: 0in;">There are also methods that
take
multiple arguments which allow programatically setting connection
values. If you'd like to set values in some fashion other than from
a properties file, these methods allow passing in values directly to
the configure method. This form of &ldquo;configure&rdquo;
lends itself well
to form based tools.</p>

<p style="margin-bottom: 0in;">The javadocs provide more
information
on the various forms of &ldquo;configure&rdquo;. And again, if
you choose to
use the Ant task to run migrations, you won't need to explicitly call
&ldquo;configure&rdquo;.</p>

<h3 class="western">The &ldquo;version&rdquo; table</h3>

<p style="margin-bottom: 0in;">The simplest way of
providing a
&ldquo;version&rdquo; table is to create a table named
&ldquo;version&rdquo; with a
single column, also named &ldquo;version&rdquo;. This table
must be created
manually. The following SQL will generate the table for most database
products:</p>

<pre>create table version (version int primary key);<br>insert into version values (0);</pre>

<p style="margin-bottom: 0in;">You may name the table
something other
than &ldquo;version&rdquo;, though you will need to tell
migrate4j about this
during configuration. The &ldquo;version&rdquo; column must be
named
&ldquo;version&rdquo;.</p>

<h1 class="western"><a name="writing" />Writing Migrations</h1>

<h3 class="western">The Up and Down methods</h3>

<p style="margin-bottom: 0in;">Database schema changes are
defined in
java classes that extend the com.eroi.migrate.Migration interface.
Besides implementing this interface, all of your Migration classes
must reside in a single package and follow a naming convention. This
allows migrate4j to locate and determine the order in which to apply
your Migrations.</p>

<p style="margin-bottom: 0in;">The
com.eroi.migrate.Migration
interface defines 2 methods: up and down. The &ldquo;up&rdquo;
method is
called by migrate4j when Migrations are being applied (for example,
going from version 0 to 1). The &ldquo;down&rdquo; method is
called when
Migrations are being rolled back (for example, when removing the
changes made in version 1, returning the database to version 0). As
you can imagine, any changes applied in the &ldquo;up&rdquo;
method should be
reversed in the &ldquo;down&rdquo; version.</p>

<h3 class="western">Naming convention</h3>

<p style="margin-bottom: 0in;">There is no default package
for
Migration classes. The package name must be specified during the
Configuration step. For example, if using the migrate4j.properties
file, set the migration.package.name property.</p>

<p style="margin-bottom: 0in;">The names of you Migration
classes are
important to allow migrate4j to understand the order in which to
apply (or rollback) your schema changes. By default,
&ldquo;Migration_1&rdquo;
is your initial Migration, followed by
&ldquo;Migration_2&rdquo;, then
&ldquo;Migration_3&rdquo; and so on. You may substitute both
the &ldquo;Migration&rdquo;
and separator (&ldquo;_&rdquo;) with other values by specifying
these changes
during Configuration (though not all forms of
&ldquo;configure&rdquo; allow
this at the current time). </p>

<p style="margin-bottom: 0in;">You define changes to your
database
schema with the Execute class. You can make your source code cleaner
by statically importing this class (including &ldquo;import static
com.eroi.migrate.Execute.*; in your class file). The Execute class
includes methods for many schema changes you may require, such as
adding/dropping tables, columns, indexes and foreign keys. Support
for stored procedures, triggers, rules, etc., are not yet implemented
but may be added in the future.</p>

<h3 class="western">Defining database changes</h3>

<p style="margin-bottom: 0in;">The Execute classes methods
take
objects that can be obtained through the Define class. Again,
statically importing this class (and it's DataTypes enum) will
significantly clean up your Migrations source code. The Define class
provides methods for creating objects that represent tables, columns,
indexes and foreign keys. Keep in mind, these objects are simply
intended for schema definitions &ndash; do not expect a table
object to
contain rows of records. </p>

<p style="margin-bottom: 0in;">While migrations are mainly
intended to
create database structure, you can also use them to add records to
your tables (useful for adding static records in lookup tables). It
is possible to obtain a connection to the database through the
Configure classes &ldquo;getConnection&rdquo; method. Use this
to add,
remove, modify, etc. records, but do not close the connection when
you're finished with it (this is difficult for many Java developers
since we're so accustomed to closing JDBC objects when finished with
them.</p>

<h1 class="western"><a name="applying" />Applying Migrations</h1>

<p style="margin-bottom: 0in;">Applying and rolling back
migrations is
done with the Engine class. It's &ldquo;migrate&rdquo; method
can be called
with a specific version number, or without any arguments. For
example, calling Engine.migrate(0) means rollback (run the
&ldquo;down&rdquo;
method) on all Migration classes found in the migration package. On
the other hand, calling Engine.migrate() means apply (run the
&ldquo;up&rdquo;
method) on all Migrations in the migration package. </p>

<p style="margin-bottom: 0in;">Using a specific version
number may
either apply, or roll back, depending on the databases current
version number. For example, calling Engine.migrate(5) will roll
back all migration named higher than Migration_6 in the migration
package if the current database version is higher than 5. On the
other hand, if the current database version is below 5, the Engine
will apply all migrations up to and including Migration_5 in the
migration package. If the database is currently at version 5, the
call has no effect.</p>

<p style="margin-bottom: 0in;">Rolling back is a normal
part of the
development process. In fact, if you unit test your database
persistence layer (for example, with DbUnit), you might consider a
full rollback and application of migrations before running your test
suite. This ensures that changes to Migration classes are applied
prior to running unit tests. When checking in code from your source
control versioning system, rollback your database schema (perhaps
with the Ant task) to a known stable version (such as
&ldquo;0&rdquo;),
compile all new files, and then apply all Migration classes. Experiment
to see what works best in your development environment.</p>

<p style="margin-bottom: 0in;">Deploying to your
production systems is
different. Obviously, rolling back a production database is not wise
since any drop statements will result in lose of data. If you find
that a schema change needs to be rolled back on your production
systems, create a new Migration class that makes the change. In
general, you never want to use anything other than Engine.migrate()
on a production system.</p>

<p style="margin-bottom: 0in;">When you first create a new
Migration
class, it's likely you won't get it right the first time. Perhaps
you create a column with the wrong data type, or you decide a name
you've used isn't descriptive enough. It's wise to keep Migrations
that are being developed separate from Migrations that have been
deployed to production. To make this easier, create two separate
packages, one for developing and one for production ready classes. For
example, create new Migration classes in a
&ldquo;dev.migrations&rdquo;
package. When you're confident they are ready to deploy to
production, copy them to &ldquo;db.migrations&rdquo;. Your
development
system can pass &ldquo;dev.migrations&rdquo; as it's migration
package name
during configuration while your production system can use
&ldquo;db.migrations&rdquo;.</p>

<h1 class="western"><a name="ant" />The Ant Task and command line Engine</h1>
<p style="margin-bottom: 0in">While your production application will
probably be limited to loading new Migration classes at startup,
you'll likely want more flexibility while developing. Migrate4j comes
with a couple of basic tools to help.</p>

<p style="margin-bottom: 0in">The com.eroi.migrate.Engine class has a
main method, allow it to be launched as a standalone application. 
You can call this from the command line, but will need to ensure your
classpath is passed (using the -cp switch) and that you have a
migrate4j.properties file.</p>

<p style="margin-bottom: 0in">Automating schema changes to coincide
with Migration class changes is made easier with an include Ant task.
 The migrate4j distribution file contains a file named
“build.sample.xml” that shows how to include the migrate4j Ant
task into your build files.</p>

<h1 class="western"><a name="help" />Getting Help</h1>

<p style="margin-bottom: 0in;">It's possible to create
migrations that
cause inconsistencies in your schema. If rolling back fails, it's
possible that reapplying will fail and you are stuck. This is not a
flaw of migrate4j, but rather a reality of programming (for migration
tools, this situation is analogous to an endless loop). The easiest
remedy is to manually drop all the tables in your database, manually
set the &ldquo;version&rdquo; column on your version table back
to &ldquo;0&rdquo;,
and then reapply your Migration classes (hopefully after you fixed
the problem that caused the error). Of course, there's no need to
roll all the way back to &ldquo;0&rdquo; - if you can identify
a known state
prior to that, by all means manually reset the database back to that
point.</p>

<p style="margin-bottom: 0in;">If you find other issues,
or need
additional help, by all means email the migrate4j mailing list at
&lt;&lt;&lt;<a href="mailto:MIGRATE4J-USERS@LISTADDRESS">MIGRATE4J-USERS@LISTADDRESS</a>&gt;&gt;&gt;.
Someone will get back to you to try to assist you.</p>

<p style="margin-bottom: 0in;">Currently, migrate4j
supports a very
small number of databases. Unfortunately, DDL (data definition
language) is much less consistent between database vendors than DML
(data manipulation language). Therefore, it's quite possible that
migrate4j will not work with your database. Again, email the mailing
list and indicate which database product you are using. There may be
work being done on your product that just hasn't made it into a
release yet &ndash; your email may be the trigger to get it
finalized.</p>

<p style="margin-bottom: 0in;">We hope you enjoy using
migrate4j and
find it useful. Comments, suggestions and questions are encouraged,
so don't be shy &ndash; send us an email and let us know what you
think!</p>

<p style="margin-bottom: 0in;"><br>

</p>
<div style="text-align: center;"><a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=207661&amp;type=4" alt="SourceForge.net Logo" border="0" height="37" width="125">

</a></div>

</body>
</html>
